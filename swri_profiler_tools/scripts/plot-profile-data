#!/usr/bin/env python
import sys
import rosbag
import numpy as np
from matplotlib import pyplot


class CallTreeNode(object):
    def __init__(self):
        self.block_id = None
        self.parent = None
        self.children = {}

        self.open = False
        self.open_stamp = None

        self.spans = []

class ThreadData(object):
    def __init__(self):
        self.earliest_time = None
        self.current_node = CallTreeNode()

    def add_data(self, data_msg):
        for event in data_msg.events:
            self.add_event(event)

    def add_event(self, event_msg):
        block_id = event_msg.event_id & ~0x01
        close_type = event_msg.event_id & 0x01
        
        if not close_type:
            self.add_open_event(block_id, event_msg.stamp)
        else:
            self.add_close_event(block_id, event_msg.stamp)

    def add_open_event(self, block_id, stamp):
        # print "open %d" % block_id
        if block_id not in self.current_node.children:
            child = CallTreeNode()
            child.block_id = block_id
            child.parent = self.current_node
            self.current_node.children[block_id] = child
            
        self.current_node = self.current_node.children[block_id]
        self.current_node.open = True
        self.current_node.open_stamp = stamp                    

    def add_close_event(self, block_id, stamp):
        # print "close %d" % block_id
        if self.current_node.block_id == block_id:
            self.current_node.open = False
            self.current_node.spans.append((self.current_node.open_stamp, stamp))
        elif self.current_node.block_id is None:
            self.current_node.block_id = block_id
            self.current_node.open = False
            self.current_node.spans.append((None, stamp))
        else:
            print self.current_node.block_id, block_id
            raise StandardError("Something is wrong in the call graph topology!")

        if self.current_node.parent is None:
            parent = CallTreeNode()
            parent.children[self.current_node.block_id] = self.current_node
            self.current_node.parent = parent
            
        self.current_node = self.current_node.parent

    def print_call_tree(self, index, prefix=''):
        root = self.current_node
        while root.parent is not None:
            root = root.parent

        self.print_node(root, index, prefix)

    def print_node(self, node, index, prefix=''):
        if len(node.spans) == 0 and node.block_id is None and len(node.children) == 1:
            # This is a phantom root node and we'll just not publish it
            child_prefix = prefix
        else:
            label = index.get(node.block_id, 'Unknown ID: ' + str(node.block_id))            
            print '%s%s : %d calls' % (prefix, label, len(node.spans))
            child_prefix = prefix + '  '        
            
        for child in node.children.values():
            self.print_node(child, index, child_prefix)

    def collect_spans(self, span_index, span_data, name_index):
        root = self.current_node
        while root.parent is not None:
            root = root.parent

        self.collect_node_spans(span_index, span_data, name_index, root)

    def collect_node_spans(self, span_index, span_data, name_index, node):
        if len(node.spans) == 0 and node.block_id is None and len(node.children) == 1:
            # This is a phantom root node and we'll just ignore it.
            pass
        else:
            label = name_index.get(node.block_id, '<unknown %s>' % str(node.block_id))
            span_index.append([label, len(span_data), []])
            span_data.append(node.spans)
            span_index = span_index[-1][-1]

        for child in node.children.values():
            self.collect_node_spans(span_index, span_data, name_index, child)
            

class ProfileData(object):    
    def __init__(self):
        self.metadata = {}
        self.index = {}
        self.data = {}

    def add_metadata_msg(self, msg):
        for item in msg.items:
            self.metadata[item.key] = item.value
        
    def add_index_msg(self, msg):
        node_name = msg.header.frame_id
        self.index[node_name] = {}
        for item in msg.index:
            self.index[node_name][item.id] = item.label

    def add_data_msg(self, msg):
        node_name = msg.header.frame_id
        if node_name not in self.data:
            self.data[node_name] = {}

        for thread in msg.threads:
            if thread.id not in self.data[node_name]:
                self.data[node_name][thread.id] = ThreadData()
            self.data[node_name][thread.id].add_data(thread)

    def print_summary(self):
        if self.metadata:
            print '='*60
            print 'Metadata:'
            for key, value in self.metadata.iteritems():
                lines = value.split('\n')
                if len(lines) == 1:
                    print '%s: %s' % (key, lines[0])
                else:
                    print '%s:' % key
                    for line in lines:
                        print '  %s' % line.rstrip()
            print '='*60
        
        for node_name, threads in self.data.iteritems():
            print 'Call tree for node %s' % node_name
            print '='*60
            for thread_id, thread in threads.iteritems():
                print '  Call tree for thread %d' % thread_id
                thread.print_call_tree(self.index[node_name], '    ')

    def collect_spans(self):
        span_index = []
        # Span index is [name, index of data, [children]
        span_data = []

        for node_name, threads in self.data.iteritems():
            for thread_id, thread in threads.iteritems():
                thread.collect_spans(span_index, span_data, self.index[node_name])
        
        return span_index, span_data

def load_profile_from_bag(bag_filename):
    INDEX_TOPIC = '/profiler/index'
    DATA_TOPIC = '/profiler/data'
    METADATA_TOPIC = '/profiler/metadata'

    bag = rosbag.Bag(bag_filename)
    profile = ProfileData()

    for (topic, msg, t) in bag.read_messages([METADATA_TOPIC, INDEX_TOPIC, DATA_TOPIC]):
        if topic == METADATA_TOPIC:
            profile.add_metadata_msg(msg)
        if topic == INDEX_TOPIC:
            profile.add_index_msg(msg)
        elif topic == DATA_TOPIC:
            profile.add_data_msg(msg)

    return profile


profile = load_profile_from_bag(sys.argv[1])
profile.print_summary()

span_index, span_data = profile.collect_spans()



def print_index(spans, prefix=''):
    for (label, index, children) in spans:
        print '%3d: %s%s' % (index, prefix, label)
        print_index(children, prefix + '  ')

print '='*60
print_index(span_index)


min_t = None
span_limits = []
for spans in span_data:
    span_limits.append([None, None])
    if len(spans) == 0:
        continue

    if spans[0][0] is not None:        
        if min_t is None:
            min_t = spans[0][0]
        else:
            min_t = min(min_t, spans[0][0])

    min_dt = None
    max_dt = None
    for span in spans:
        if None in span:
            continue
        span = span[1] - span[0]

        if min_dt is None:
            min_dt = span
        else:
            min_dt = min(min_dt, span)

        if max_dt is None:
            max_dt = span
        else:
            max_dt = max(max_dt, span)
        
        span_limits[-1] = [min_dt, max_dt]
        

X = []
Y = []
for i, spans in enumerate(span_data):
    for span in spans:
        if None in span:
            continue
        dt = (span[1] - span[0])
        min_dt = span_limits[i][0]
        max_dt = span_limits[i][1]

        size = 0.4
        # These are inverted because we're going to invert the plot
        min_y = i + size
        max_y = i - size

        if min_dt == max_dt:
            y = i
        else:
            y = (dt - min_dt).to_sec() / (max_dt - min_dt).to_sec() * (max_y - min_y) + min_y

        t0 = (span[0] - min_t).to_sec()
        tf = (span[1] - min_t).to_sec()
        
        X.append(t0)
        Y.append(y)
        X.append(tf)
        Y.append(y)
        X.append(None)
        Y.append(None)

        X.append(t0)
        Y.append(min_y)
        X.append(t0)
        Y.append(max_y)
        X.append(None)
        Y.append(None)

        X.append(tf)
        Y.append(min_y)
        X.append(tf)
        Y.append(max_y)
        X.append(None)
        Y.append(None)
    
pyplot.plot(X,Y, 'k')
# Invert the plot so that the vertical layout matches the printed index.
pyplot.ylim([len(span_data), -1])
pyplot.show()

